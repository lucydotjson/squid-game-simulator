<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Squid Game Simulator - Merged</title>
<style>
  * { box-sizing: border-box; }
  body, html {
    margin: 0; padding: 0; min-height: 100vh;
    background: #111;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    color: white;
    /* overflow: hidden; */
    user-select: none;
  }
  .outlined-text {
    color: white;
    text-shadow:
      -1px -1px 0 #000,
      1px -1px 0 #000,
      -1px 1px 0 #000,
      1px 1px 0 #000;
  }
  body::before {
    content: "";
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    pointer-events: none;
    background:
      linear-gradient(0deg, #ffe0f7 1px, transparent 1px),
      linear-gradient(90deg, #ffe0f7 1px, transparent 1px);
    background-size: 40px 40px;
    animation: moveGrid 30s linear infinite;
    z-index: 0;
    opacity: 0.25;
  }
  @keyframes moveGrid {
    from { background-position: 0 0, 0 0; }
    to { background-position: 800px 800px, 800px 800px; }
  }
  #startScreen, #gameScreen {
    position: absolute; inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 20px;
    background: rgba(20,20,20,0.85);
  }
  #gameScreen { display: none; }
  h1 {
    font-weight: 900;
    font-size: 3rem;
    margin-bottom: 10px;
    user-select:none;
  }
  button {
    font-size: 1.25rem;
    background: #ff3fa6;
    border: none;
    border-radius: 6px;
    padding: 12px 24px;
    cursor: pointer;
    color: white;
    font-weight: 700;
    transition: background-color 0.3s ease;
    user-select:none;
  }
  button:disabled {
    background: #666;
    cursor: not-allowed;
  }
  button:hover:not(:disabled) {
    background: #e22e91;
  }
  input[type=text] {
    font-size: 1rem;
    padding: 6px 10px;
    border-radius: 4px;
    border: 1px solid #555;
    margin-right: 10px;
    width: 200px;
    outline: none;
    background: #222;
    color: white;
    text-shadow: none;
  }
  input[type=file] { display: none; }
  label.file-label {
    background: #ff3fa6;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    font-weight: 600;
    user-select:none;
  }
  label.file-label:hover { background: #e22e91; }
  .hex-grid {
    width: 100%;
    max-width: 1000px;
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    margin-top: 20px;
  }
  .hex {
    position: relative;
    width: 100px;
    height: 115px;
    margin: 0 6px 10px;
    cursor: default;
    user-select:none;
    transition: transform 0.3s ease, filter 0.4s ease;
  }
  .hex:hover {
    transform: scale(1.05);
    filter: brightness(1.2);
  }
  .hex.eliminated {
    filter: grayscale(90%) brightness(0.5);
    cursor: not-allowed;
    opacity: 0.5;
  }
  .hex-content {
    width: 100px;
    height: 115px;
    background: #222;
    clip-path: polygon(
      50% 0%,
      93% 25%,
      93% 75%,
      50% 100%,
      7% 75%,
      7% 25%
    );
    border: 2px solid #ff3fa6;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-sizing: border-box;
    padding: 6px;
    color: white;
    text-align: center;
  }
  .hex-avatar {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    background: #333;
    margin-bottom: 8px;
    object-fit: cover;
    border: 2px solid #ff3fa6;
    box-shadow: 0 0 5px #ff3fa6;
  }
  .hex-initials {
    font-weight: 900;
    font-size: 1.8rem;
    color: #ff3fa6;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 64px;
    height: 64px;
    border-radius: 50%;
    border: 2px solid #ff3fa6;
    box-shadow: 0 0 8px #ff3fa6;
    margin-bottom: 8px;
    user-select:none;
  }
  .hex-name-above {
    font-weight: 700;
    font-size: 1rem;
    line-height: 1.2em;
    color: white;
    text-shadow:
      -1px -1px 1px black,
      1px -1px 1px black,
      -1px 1px 1px black,
      1px 1px 1px black;
    user-select:none;
    margin-bottom: 2px;
    margin-top: 0.2em;
    text-align: center;
    width: 100%;
    position: relative;
    z-index: 2;
    white-space: pre-line;
    word-break: break-word;
  }
  /* .hex-name { ... } remains for legacy, but not used */
  .hex-row-offset { margin-left: 53px; }
  #inputArea {
    display: flex;
    align-items: center;
    margin-bottom: 10px;
    flex-wrap: wrap;
    gap: 10px;
  }
  #gameLog {
    margin-top: 20px;
    padding: 12px;
    background: rgba(10,10,10,0.8);
    border-radius: 8px;
    width: 90%;
    max-width: 1000px;
    max-height: 300px;
    overflow-y: auto;
    font-size: 1.1rem;
    line-height: 1.4;
    box-shadow: 0 0 12px #ff3fa6aa;
  }
  #gameLog p {
    margin: 6px 0;
    opacity: 0;
    animation: fadeInText 0.6s forwards;
    user-select:none;
  }
  @keyframes fadeInText { to {opacity: 1;} }
  #prizeMoneyDisplay {
    margin-top: 20px;
    font-weight: 900;
    font-size: 1.5rem;
    color: gold;
    text-shadow:
      -2px -2px 2px black,
      2px -2px 2px black,
      -2px 2px 2px black,
      2px 2px 2px black;
    user-select:none;
  }

  
/* Cinematic overlay styles */
  #cinematicOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    z-index: 10000;
    display: flex;
    align-items: center;
    justify-content: center;
    pointer-events: none;
    background: rgba(0,0,0,0.7);
    opacity: 0;
    transition: opacity 0.7s cubic-bezier(.4,0,.2,1);
    font-family: 'Segoe UI', Impact, Arial, sans-serif;
  }
  #cinematicOverlay.active {
    opacity: 1;
    pointer-events: all;
  }
  .cinematic-text {
    color: #fff;
    font-size: 4vw;
    font-weight: 900;
    letter-spacing: 0.1em;
    text-shadow: 0 4px 32px #000, 0 0 8px #f33;
    opacity: 0;
    animation: fadeInCinematic 1.2s cubic-bezier(.4,0,.2,1) forwards;
  }
  @keyframes fadeInCinematic {
    0% { opacity: 0; transform: scale(1.2); }
    60% { opacity: 1; transform: scale(1); }
    100% { opacity: 1; transform: scale(1); }
  }
  /* Hexagon entrance animation */
  .hex-entrance {
    opacity: 0;
    transform: scale(0.7);
    animation: hexEntrance 0.5s cubic-bezier(.4,0,.2,1) forwards;
  }
  @keyframes hexEntrance {
    0% { opacity: 0; transform: scale(0.7); }
    80% { opacity: 1; transform: scale(1.1); }
    100% { opacity: 1; transform: scale(1); }
  }
  /* Glow for passed */
  .hex-passed {
    box-shadow: 0 0 0 0 #0f0, 0 0 24px 8px #0f08;
    border-color: #0f0 !important;
    animation: hexGlow 1.2s cubic-bezier(.4,0,.2,1) forwards;
  }
  @keyframes hexGlow {
    0% { box-shadow: 0 0 0 0 #0f0, 0 0 0 0 #0f0; }
    60% { box-shadow: 0 0 24px 8px #0f08, 0 0 0 0 #0f0; }
    100% { box-shadow: 0 0 16px 4px #0f08, 0 0 0 0 #0f0; }
  }
  /* Elimination darken effect */
  .hex-eliminated-cinematic {
    filter: grayscale(100%) brightness(0.3) blur(0.5px);
    opacity: 0.7;
    transition: filter 0.7s, opacity 0.7s;
  }
</style>
</head>
<body>
<style>
  .screen-fade {
    opacity: 1;
    transition: opacity 0.7s cubic-bezier(.4,0,.2,1);
  }
  .screen-fade.hide {
    opacity: 0;
    pointer-events: none;
  }
</style>

<style>
#cinematicPlayerOverlay {
  position: fixed;
  inset: 0;
  z-index: 10001;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  pointer-events: none;
  background: rgba(0,0,0,0.85);
  opacity: 0;
  transition: opacity 0.5s cubic-bezier(.4,0,.2,1);
}
#cinematicPlayerOverlay.active {
  opacity: 1;
  pointer-events: all;
}
.cinematic-player-grid {
  display: flex;
  gap: 3vw;
  margin-bottom: 2vw;
}
.cinematic-player-icon {
  display: flex;
  flex-direction: column;
  align-items: center;
  animation: hexEntrance 0.5s cubic-bezier(.4,0,.2,1) forwards;
}
.cinematic-player-avatar {
  width: 90px;
  height: 90px;
  border-radius: 50%;
  border: 3px solid #ff3fa6;
  background: #222;
  object-fit: cover;
  box-shadow: 0 0 12px #ff3fa6;
}
.cinematic-player-name {
  margin-top: 10px;
  font-weight: 700;
  font-size: 1.2rem;
  color: #fff;
  text-shadow: 0 0 8px #000;
}
.cinematic-status-message {
  color: #fff;
  font-size: 2vw;
  font-weight: 900;
  letter-spacing: 0.05em;
  text-shadow: 0 4px 32px #000, 0 0 8px #f33;
  margin-top: 1vw;
  text-align: center;
}
@keyframes hexEntrance {
  0% { opacity: 0; transform: scale(0.7);}
  80% { opacity: 1; transform: scale(1.1);}
  100% { opacity: 1; transform: scale(1);}
}
</style>
  
<div id="cinematicOverlay"></div>
<div id="cinematicPlayerOverlay"></div>

<!-- START SCREEN -->
<div id="startScreen" class="screen-fade">
  <h1 class="outlined-text">Squid Game Simulator</h1>
  <div id="inputArea">
    <input id="characterNameInput" type="text" placeholder="Character Name" />
    <label for="characterImageInput" class="file-label">Upload Avatar</label>
    <input id="characterImageInput" type="file" accept="image/*" />
    <button id="addCharacterBtn">Add Character</button>
    <button id="autoFillBtn" style="margin-top:10px;">Auto Fill</button>

  </div>
  <div id="characterGrid" class="hex-grid" aria-label="Character selection grid"></div>
  <button id="startGameBtn" disabled>Start Game</button>
</div>
<!-- GAME SCREEN -->
<div id="gameScreen" class="screen-fade hide">
  <h1 class="outlined-text">Squid Game Simulator</h1>
  <div id="characterGridGame" class="hex-grid" aria-label="Active players grid"></div>
  <div id="prizeMoneyDisplay" class="outlined-text">ðŸ’° Prize Pool: $0</div>
</div>
<!-- Audio Elements -->
<audio id="audioStart" src="https://cdn.pixabay.com/download/audio/2022/03/23/audio_16cbd9a4cd.mp3?filename=short-game-start-6341.mp3" preload="auto"></audio>
<audio id="audioElimination" src="https://cdn.pixabay.com/download/audio/2021/09/09/audio_2f46b2a1e2.mp3?filename=game-over-arcade-6435.mp3" preload="auto"></audio>
<audio id="audioGameEnd" src="https://cdn.pixabay.com/download/audio/2022/04/27/audio_bce6e0ea99.mp3?filename=game-victory-fanfare-6345.mp3" preload="auto"></audio>
<script>
(() => {
  // DOM Elements
  const characterNameInput = document.getElementById('characterNameInput');
  const characterImageInput = document.getElementById('characterImageInput');
  const addCharacterBtn = document.getElementById('addCharacterBtn');
  const startGameBtn = document.getElementById('startGameBtn');
  const characterGrid = document.getElementById('characterGrid');
  const characterGridGame = document.getElementById('characterGridGame');
  const startScreen = document.getElementById('startScreen');
  const gameScreen = document.getElementById('gameScreen');
  const prizeMoneyDisplay = document.getElementById('prizeMoneyDisplay');
  // Audio elements
  const audioStart = document.getElementById('audioStart');
  const audioElimination = document.getElementById('audioElimination');
  const audioGameEnd = document.getElementById('audioGameEnd');

    const autoFillBtn = document.getElementById('autoFillBtn');
// Place this inside your main script, replacing your current autoFillBtn.onclick handler
/* Replace the FRUITS and OBJECTS arrays in your script with the following: */

const FRUITS = [
  // Fruits
  "Apple", "Banana", "Orange", "Strawberry", "Pineapple", "Mango", "Watermelon", "Grape", "Peach", "Cherry", "Lemon", "Blueberry",
  "Raspberry", "Blackberry", "Kiwi", "Papaya", "Guava", "Lychee", "Coconut", "Apricot", "Plum", "Pear", "Fig", "Pomegranate",
  "Cantaloupe", "Honeydew", "Dragonfruit", "Passionfruit", "Starfruit", "Durian", "Jackfruit", "Tangerine", "Cranberry", "Gooseberry",
  "Mulberry", "Persimmon", "Quince", "Soursop", "Longan", "Rambutan", "Date", "Currant", "Elderberry", "Boysenberry", "Salak", "Tamarind"
];

const OBJECTS = [
  // Household objects
  "Chair", "Table", "Lamp", "Bicycle", "Umbrella", "Backpack", "Clock", "Pillow", "Book", "Spoon", "Glasses", "Camera",
  "Toaster", "Microwave", "Television", "Laptop", "Smartphone", "Headphones", "Mug", "Bottle", "Pen", "Pencil", "Notebook", "Scissors",
  "Stapler", "Ruler", "Calculator", "Remote", "Sofa", "Bed", "Blanket", "Mirror", "Toothbrush", "Comb", "Shoe", "Sock", "Hat", "Glove",
  "Wallet", "Key", "Door", "Window", "Curtain", "Fan", "Heater", "Drill", "Hammer", "Screwdriver", "Wrench", "Plunger", "Broom", "Mop"
];

// Memes & Internet icons
const MEMES = [
  "Doge", "Pepe the Frog", "Shrek", "Big Chungus", "Cheems", "Grumpy Cat", "Nyan Cat", "Trollface", "Distracted Boyfriend", "Woman Yelling at Cat",
  "Hide the Pain Harold", "Success Kid", "Bad Luck Brian", "Epic Sax Guy", "Rick Astley", "Giga Chad", "Among Us Crewmate", "Swole Doge vs Cheems",
  "Is This a Pigeon?", "Surprised Pikachu", "Galaxy Brain", "Mocking SpongeBob", "Arthur Fist", "Y U NO Guy", "Kermit Sipping Tea"
];


// Celebrities (for fun)
const CELEBRITIES = [
  "Taylor Swift", "Elon Musk", "Barack Obama", "Oprah Winfrey", "Dwayne Johnson", "BeyoncÃ©", "Keanu Reeves", "Rihanna",
  "Tom Hanks", "Lady Gaga", "Bill Gates", "Ariana Grande", "Leonardo DiCaprio", "Zendaya", "Will Smith", "Emma Watson",
  "Cristiano Ronaldo", "Lionel Messi", "Selena Gomez", "Kim Kardashian", "PewDiePie", "MrBeast", "Markiplier", "Ninja", "Pokimane"
];

// Combine all for autofill
const ALL_AUTOFILL = [
  ...FRUITS,
  ...OBJECTS,
  ...MEMES,
  ...CELEBRITIES
];

autoFillBtn.onclick = async () => {
  autoFillBtn.disabled = true;
  autoFillBtn.textContent = "Loading...";

  // Get names already present (case-insensitive)
  const existingNames = new Set(characters.map(c => c.name.toLowerCase()));

  // Filter out names already present
  const availableTitles = ALL_AUTOFILL.filter(
    name => !existingNames.has(name.toLowerCase())
  );

  // Pick up to 12 random unique names from available
  function pickRandom(arr, n) {
    const shuffled = arr.slice().sort(() => Math.random() - 0.5);
    return shuffled.slice(0, n);
  }
  const allTitles = pickRandom(availableTitles, 12);

  // Helper to get image for a Wikipedia page
  async function fetchWikiImage(title) {
    const url = `https://en.wikipedia.org/w/api.php?action=query&titles=${encodeURIComponent(title)}&prop=pageimages&format=json&pithumbsize=200&origin=*`;
    try {
      const resp = await fetch(url);
      const data = await resp.json();
      const pages = data.query.pages;
      for (const key in pages) {
        if (pages[key].thumbnail && pages[key].thumbnail.source) {
          return pages[key].thumbnail.source;
        }
      }
    } catch {}
    return '';
  }

  // (Optional: Add your SQUID_GAME_IMAGES mapping here if you want to use Fandom images for those characters)

  for (const title of allTitles) {
    let img = '';
    // If you have SQUID_GAME_IMAGES mapping, use it here:
    // if (SQUID_GAME_IMAGES[title]) {
    //   img = SQUID_GAME_IMAGES[title];
    // } else {
      try {
        img = await fetchWikiImage(title);
      } catch {}
    // }
    characters.push({ name: title, img });
  }
  renderCharacterGrid();
  checkStartButton();
  autoFillBtn.disabled = false;
  autoFillBtn.textContent = "Auto Fill";
};

  // Data storage
  let characters = [];
  let eliminatedSet = new Set();
  let currentPrize = 0;
  let objectURLs = [];

  // Utility
  function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }
  function randInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
  function randomChoice(arr) { return arr[randInt(0, arr.length -1)]; }

  // Cinematic overlay API
  async function showCinematicText(text, duration = 1800) {
    const overlay = document.getElementById('cinematicOverlay');
    overlay.innerHTML = `<div class="cinematic-text">${text}</div>`;
    overlay.classList.add('active');
    await sleep(duration);
    overlay.classList.remove('active');
    await sleep(700);
    overlay.innerHTML = '';
  }

  function showCinematicPlayers(players, statusMessage = "", duration = 2000) {
    return new Promise(resolve => {
      const overlay = document.getElementById('cinematicPlayerOverlay');
      overlay.innerHTML = `
        <div class="cinematic-player-grid">
          ${players.map(p => `
            <div class="cinematic-player-icon">
              <img class="cinematic-player-avatar" src="${p.img || ''}" alt="${p.name}">
              <div class="cinematic-player-name">${p.name}</div>
            </div>
          `).join('')}
        </div>
        ${statusMessage ? `<div class="cinematic-status-message">${statusMessage}</div>` : ''}
      `;
      overlay.classList.add('active');
      // Hide main grid while overlay is active
      document.getElementById('characterGridGame').style.visibility = 'hidden';
      setTimeout(() => {
        overlay.classList.remove('active');
        setTimeout(() => {
          overlay.innerHTML = '';
          document.getElementById('characterGridGame').style.visibility = '';
          resolve();
        }, 500);
      }, duration);
    });
  }
  function hideCinematicPlayers() {
    const overlay = document.getElementById('cinematicPlayerOverlay');
    overlay.classList.remove('active');
    overlay.innerHTML = '';
    document.getElementById('characterGridGame').style.visibility = '';
  }

  async function showPlayerAction({type, from, to, fromImg, toImg, message, duration = 1800}) {
    const overlay = document.getElementById('cinematicOverlay');
    let html = '';
    if (type === 'push') {
      html = `<div style="display:flex;align-items:center;gap:2vw;justify-content:center;">
        <div style="text-align:center;">
          <img src="${fromImg || ''}" alt="${from}" style="width:80px;height:80px;border-radius:50%;border:3px solid #fff;background:#222;object-fit:cover;box-shadow:0 0 12px #f33;">
          <div style="margin-top:8px;font-weight:700;">${from}</div>
        </div>
        <div style="font-size:2.5vw;font-weight:900;color:#f33;text-shadow:0 0 8px #000;">PUSHES</div>
        <div style="text-align:center;">
          <img src="${toImg || ''}" alt="${to}" style="width:80px;height:80px;border-radius:50%;border:3px solid #fff;background:#222;object-fit:cover;filter:grayscale(1) brightness(0.4);box-shadow:0 0 12px #000;">
          <div style="margin-top:8px;font-weight:700;">${to}</div>
        </div>
      </div>
      <div style="margin-top:2vw;font-size:2vw;color:#fff;text-shadow:0 0 8px #000;">${message || (to + ' eliminated!')}</div>`;
    } else if (type === 'caught') {
      html = `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <img src="${fromImg || ''}" alt="${from}" style="width:80px;height:80px;border-radius:50%;border:3px solid #fff;background:#222;object-fit:cover;filter:grayscale(1) brightness(0.4);box-shadow:0 0 12px #000;">
        <div style="margin-top:8px;font-weight:700;">${from}</div>
        <div style="margin-top:2vw;font-size:2vw;color:#f33;text-shadow:0 0 8px #000;">CAUGHT MOVING - ELIMINATED</div>
      </div>`;
    } else if (type === 'pass') {
      html = `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <img src="${fromImg || ''}" alt="${from}" style="width:80px;height:80px;border-radius:50%;border:3px solid #0f0;background:#222;object-fit:cover;box-shadow:0 0 24px 8px #0f08;">
        <div style="margin-top:8px;font-weight:700;">${from}</div>
        <div style="margin-top:2vw;font-size:2vw;color:#0f0;text-shadow:0 0 8px #000;">SAFE</div>
      </div>`;
    } else if (type === 'fail') {
      html = `<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;">
        <img src="${fromImg || ''}" alt="${from}" style="width:80px;height:80px;border-radius:50%;border:3px solid #f33;background:#222;object-fit:cover;filter:grayscale(1) brightness(0.4);box-shadow:0 0 12px #000;">
        <div style="margin-top:8px;font-weight:700;">${from}</div>
        <div style="margin-top:2vw;font-size:2vw;color:#f33;text-shadow:0 0 8px #000;">ELIMINATED</div>
      </div>`;
    }
    overlay.innerHTML = `<div class="cinematic-text" style="animation:none;opacity:1;">${html}</div>`;
    overlay.classList.add('active');
    await sleep(duration);
    overlay.classList.remove('active');
    await sleep(700);
    overlay.innerHTML = '';
  }

  function getCharImg(name) {
    const c = characters.find(c => c.name === name);
    return c && c.img ? c.img : '';
  }

  // Animate hexagon pass/fail
  function markPassed(name) {
    const hexes = document.querySelectorAll('.hex');
    for (const hex of hexes) {
      const label = hex.querySelector('.hex-name-above');
      if (label && label.textContent === name) {
        const hexContent = hex.querySelector('.hex-content');
        hexContent.classList.add('hex-passed');
      }
    }
  }
  function markEliminated(name) {
    const hexes = document.querySelectorAll('.hex');
    for (const hex of hexes) {
      const label = hex.querySelector('.hex-name-above');
      if (label && label.textContent === name) {
        const hexContent = hex.querySelector('.hex-content');
        hexContent.classList.add('hex-eliminated-cinematic');
      }
    }
  }
  function clearHexEffects() {
    const hexes = document.querySelectorAll('.hex-content');
    for (const hex of hexes) {
      hex.classList.remove('hex-passed', 'hex-eliminated-cinematic');
    }
  }

  // Add character
  addCharacterBtn.onclick = () => {
    const name = characterNameInput.value.trim().replace(/[<>&"'`]/g, '');
    if(!name) return alert('Please enter a character name.');
    if(characters.some(c => c.name.toLowerCase() === name.toLowerCase())) {
      alert('Character name already exists.');
      return;
    }
    const imgFile = characterImageInput.files[0];
    let imgURL = '';
    if(imgFile) {
      if(!imgFile.type.startsWith('image/')) {
        alert('Only image files are allowed.');
        return;
      }
      imgURL = URL.createObjectURL(imgFile);
      objectURLs.push(imgURL);
    }
    characters.push({name, img: imgURL});
    characterNameInput.value = '';
    characterImageInput.value = '';
    renderCharacterGrid();
    checkStartButton();
  };

  function renderCharacterGrid() {
    characterGrid.innerHTML = '';
    for(let i = 0; i < characters.length; i++) {
      const char = characters[i];
      const hex = document.createElement('div');
      hex.className = 'hex';
      const perRow = 6;
      const row = Math.floor(i / perRow);
      if(row % 2 === 1) hex.style.marginLeft = '53px';
      const hexContent = document.createElement('div');
      hexContent.className = 'hex-content';
      if(char.img) {
        const img = document.createElement('img');
        img.className = 'hex-avatar';
        img.src = char.img;
        img.alt = `${char.name} avatar`;
        hexContent.appendChild(img);
      } else {
        const initials = getInitials(char.name);
        const fallback = document.createElement('div');
        fallback.className = 'hex-initials';
        fallback.textContent = initials;
        hexContent.appendChild(fallback);
      }
      // Name above hexagon
      const nameDiv = document.createElement('div');
      nameDiv.className = 'hex-name-above';
      nameDiv.textContent = char.name;
      hex.appendChild(nameDiv);
      hex.appendChild(hexContent);

      // Double-click to delete (only before game starts)
      if (gameScreen.style.display === "none" || startScreen.style.display !== "none") {
        let clickTimeout = null;
        hex.addEventListener('click', function() {
          if (clickTimeout) {
            // Double click detected
            clickTimeout = clearTimeout(clickTimeout);
            if (confirm(`Delete "${char.name}"?`)) {
              // Remove character and revoke image URL if needed
              if (char.img) {
                try { URL.revokeObjectURL(char.img); } catch {}
              }
              characters.splice(i, 1);
              renderCharacterGrid();
              checkStartButton();
            }
          } else {
            clickTimeout = setTimeout(() => {
              clickTimeout = null;
            }, 300);
          }
        });
      }

      characterGrid.appendChild(hex);
    }
  }

  function renderCharacterGridGame() {
    characterGridGame.innerHTML = '';
    for(let i = 0; i < characters.length; i++) {
      const char = characters[i];
      const hex = document.createElement('div');
      hex.className = 'hex';
      const perRow = 6;
      const row = Math.floor(i / perRow);
      if(row % 2 === 1) hex.style.marginLeft = '53px';
      if(eliminatedSet.has(char.name)) {
        hex.classList.add('eliminated');
        hex.style.pointerEvents = 'none';
      }
      const hexContent = document.createElement('div');
      hexContent.className = 'hex-content';
      if(char.img) {
        const img = document.createElement('img');
        img.className = 'hex-avatar';
        img.src = char.img;
        img.alt = `${char.name} avatar`;
        hexContent.appendChild(img);
      } else {
        const initials = getInitials(char.name);
        const fallback = document.createElement('div');
        fallback.className = 'hex-initials';
        fallback.textContent = initials;
        hexContent.appendChild(fallback);
      }
      // Name above hexagon
      const nameDiv = document.createElement('div');
      nameDiv.className = 'hex-name-above';
      nameDiv.textContent = char.name;
      hex.appendChild(nameDiv);
      hex.appendChild(hexContent);
      characterGridGame.appendChild(hex);
    }
  }

  function getInitials(name) {
    const parts = name.split(' ').filter(p => p.length > 0);
    if(parts.length === 1) return parts[0][0].toUpperCase();
    return (parts[0][0] + parts[1][0]).toUpperCase();
  }

  function checkStartButton() {
    startGameBtn.disabled = characters.length < 3;
  }

  // REMOVED: addLogLine and log box system for cinematic experience

  async function tweenNumber(from, to, duration = 1500) {
    const steps = 30;
    const stepTime = duration / steps;
    for (let i = 0; i <= steps; i++) {
      const value = Math.floor(from + (to - from) * (i / steps));
      prizeMoneyDisplay.textContent = `ðŸ’° Prize Pool: $${value.toLocaleString()}`;
      await sleep(stepTime);
    }
  }

  function playSound(audioElem) {
    audioElem.currentTime = 0;
    const playPromise = audioElem.play();
    if(playPromise !== undefined) {
      playPromise.catch(() => {});
    }
  }

  // --- Squid Game Simulator Game Logic (Merged, Cinematic Only) ---
  const GameManager = {
    currentDay: 0,
    maxDays: 6,
    dayGames: [
      "Red Light, Green Light",
      "Dalgona/Honeycomb",
      "Tug of War",
      "Marbles",
      "Glass Bridge",
      "Squid Game"
    ],
    async startGame() {
      this.currentDay = 0;
      eliminatedSet.clear();
      currentPrize = 0;
      renderCharacterGridGame();
      clearHexEffects();
      await showCinematicText("ðŸ”” The game is starting...");
      playSound(audioStart);
      await sleep(700);
      await this.nextDay();
    },
    async nextDay() {
      const alive = this.remainingPlayers();
      if (alive.length <= 1 || this.currentDay >= this.maxDays) {
        return this.endGame();
      }
      this.currentDay++;
      await showCinematicText(`DAY ${this.currentDay}`);
      await sleep(400);
      // Main game for the day
      const gameName = this.dayGames[this.currentDay - 1];
      await showCinematicText(`GAME STARTS - ${gameName.toUpperCase()}`);
      await sleep(400);
      let eliminated = await this.playGame(gameName, this.remainingPlayers());
      // Ensure at least 1 eliminated (unless only 1 left)
      if (eliminated.length === 0 && this.remainingPlayers().length > 1) {
        eliminated = [randomChoice(this.remainingPlayers())];
      }
      for (const name of eliminated) {
        eliminatedSet.add(name);
        markEliminated(name);
        playSound(audioElimination);
        await showPlayerAction({type: 'fail', from: name, fromImg: getCharImg(name)});
        await this.increasePrize();
        await this.vipComment();
      }
      renderCharacterGridGame();
      await sleep(700);
      // Night Attack after main game
      if (this.remainingPlayers().length > 1) {
        await showCinematicText("NIGHT ATTACK SEQUENCE");
        await sleep(400);
        let nightEliminated = await this.playGame("Night Attack", this.remainingPlayers());
        if (nightEliminated.length === 0 && this.remainingPlayers().length > 1) {
          nightEliminated = [randomChoice(this.remainingPlayers())];
        }
        for (const name of nightEliminated) {
          eliminatedSet.add(name);
          markEliminated(name);
          playSound(audioElimination);
          await showPlayerAction({type: 'fail', from: name, fromImg: getCharImg(name)});
          await this.increasePrize();
          await this.vipComment();
        }
        renderCharacterGridGame();
        await sleep(700);
      }
      // If only one left, end immediately
      if (this.remainingPlayers().length <= 1) {
        return this.endGame();
      }
      await this.nextDay();
    },
    remainingPlayers() {
      return characters.map(c => c.name).filter(name => !eliminatedSet.has(name));
    },
    async endGame() {
      const survivors = this.remainingPlayers();
      if (survivors.length === 1) {
        await showCinematicText(`${survivors[0]} is the final winner!`);
        playSound(audioGameEnd);
      } else if (survivors.length > 1) {
        await showCinematicText("FINAL ROUND: SQUID GAME!");
        await sleep(700);
        const finalWinner = randomChoice(survivors);
        for (const name of survivors) {
          if (name !== finalWinner) {
            eliminatedSet.add(name);
            markEliminated(name);
            await showPlayerAction({type: 'fail', from: name, fromImg: getCharImg(name)});
            playSound(audioElimination);
          }
        }
        await showCinematicText(`${finalWinner} wins Squid Game!`);
        playSound(audioGameEnd);
      } else {
        await showCinematicText("No survivors. The game ends in tragedy.");
      }
      renderCharacterGridGame();
      // Show restart
      const restartBtn = document.createElement('button');
      restartBtn.textContent = 'Restart Game';
      restartBtn.style.marginTop = '20px';
      restartBtn.onclick = () => {
        objectURLs.forEach(url => URL.revokeObjectURL(url));
        location.reload();
      };
      document.getElementById('cinematicOverlay').innerHTML = '';
      document.getElementById('cinematicOverlay').classList.remove('active');
      document.getElementById('gameScreen').appendChild(restartBtn);
    },
    async playGame(gameName, players) {
      switch (gameName) {
        case "Red Light, Green Light": {
          let eliminated = [];
          for (const player of players) {
            if (Math.random() < 0.3) {
              eliminated.push(player);
              await showCinematicPlayers(
                [{ name: player, img: getCharImg(player) }],
                `${player} was caught moving and eliminated!`,
                2000
              );
            } else {
              await showCinematicPlayers(
                [{ name: player, img: getCharImg(player) }],
                `${player} stands still safely.`,
                1200
              );
            }
          }
          if (eliminated.length === 0 && players.length > 1) {
            const forced = randomChoice(players);
            eliminated.push(forced);
            await showCinematicPlayers(
              [{ name: forced, img: getCharImg(forced) }],
              `${forced} was caught at the last second and eliminated!`,
              2000
            );
          }
          return eliminated;
        }
        case "Dalgona/Honeycomb": {
          const shapes = [
            { name: "Triangle", rate: 0.9 },
            { name: "Circle", rate: 0.7 },
            { name: "Star", rate: 0.4 },
            { name: "Umbrella", rate: 0.1 }
          ];
          let eliminated = [];
          for (const player of players) {
            const shape = randomChoice(shapes);
            await showCinematicPlayers(
              [{ name: player, img: getCharImg(player) }],
              `${player} picks ${shape.name} (${Math.round(shape.rate*100)}% win rate).`,
              1200
            );
            if (Math.random() > shape.rate) {
              eliminated.push(player);
              await showCinematicPlayers(
                [{ name: player, img: getCharImg(player) }],
                `${player} failed the ${shape.name} and is eliminated!`,
                2000
              );
            } else {
              await showCinematicPlayers(
                [{ name: player, img: getCharImg(player) }],
                `${player} completes the ${shape.name} successfully!`,
                1200
              );
            }
          }
          if (eliminated.length === 0 && players.length > 1) {
            const forced = randomChoice(players);
            eliminated.push(forced);
            await showCinematicPlayers(
              [{ name: forced, img: getCharImg(forced) }],
              `${forced} dropped their candy at the last second and is eliminated!`,
              2000
            );
          }
          return eliminated;
        }
        case "Tug of War": {
          if (players.length <= 4) {
            const forced = randomChoice(players);
            await showCinematicPlayers(
              [{ name: forced, img: getCharImg(forced) }],
              `Not enough for teams. ${forced} is eliminated!`,
              2000
            );
            return [forced];
          }
          // Split into two teams, eliminate all of one team
          const shuffled = [...players].sort(() => Math.random() - 0.5);
          const mid = Math.floor(shuffled.length / 2);
          const teamA = shuffled.slice(0, mid);
          const teamB = shuffled.slice(mid);
          await showCinematicPlayers(
            teamA.map(name => ({ name, img: getCharImg(name) })),
            `Team A: ${teamA.join(", ")}`,
            1500
          );
          await showCinematicPlayers(
            teamB.map(name => ({ name, img: getCharImg(name) })),
            `Team B: ${teamB.join(", ")}`,
            1500
          );
          const losingTeam = Math.random() < 0.5 ? teamA : teamB;
          const winningTeam = losingTeam === teamA ? teamB : teamA;
          await showCinematicPlayers(
            losingTeam.map(name => ({ name, img: getCharImg(name) })),
            `Team ${losingTeam === teamA ? 'A' : 'B'} loses and is eliminated!`,
            2000
          );
          if (losingTeam.length === 0) {
            const forced = randomChoice(players);
            await showCinematicPlayers(
              [{ name: forced, img: getCharImg(forced) }],
              `${forced} is eliminated by default!`,
              2000
            );
            return [forced];
          }
          return losingTeam;
        }
        case "Marbles": {
          // Pair up, loser of each pair is eliminated, at least 1
          const shuffled = [...players].sort(() => Math.random() - 0.5);
          const eliminated = [];
          for (let i = 0; i < shuffled.length - 1; i += 2) {
            const p1 = shuffled[i];
            const p2 = shuffled[i + 1];
            const winner = randomChoice([p1, p2]);
            const loser = winner === p1 ? p2 : p1;
            await showCinematicPlayers(
              [
                { name: p1, img: getCharImg(p1) },
                { name: p2, img: getCharImg(p2) }
              ],
              `${p1} vs ${p2}: ${winner} wins, ${loser} eliminated!`,
              2500
            );
            eliminated.push(loser);
          }
          if (eliminated.length === 0 && players.length > 1) {
            const forced = randomChoice(players);
            eliminated.push(forced);
            await showCinematicPlayers(
              [{ name: forced, img: getCharImg(forced) }],
              `${forced} lost their marbles at the last second and is eliminated!`,
              2000
            );
          }
          return eliminated;
        }
        case "Glass Bridge": {
          let eliminated = [];
          for (const player of players) {
            if (Math.random() < 0.4) {
              eliminated.push(player);
              await showCinematicPlayers(
                [{ name: player, img: getCharImg(player) }],
                `${player} falls through the glass and is eliminated!`,
                2000
              );
            } else {
              await showCinematicPlayers(
                [{ name: player, img: getCharImg(player) }],
                `${player} crosses safely.`,
                1200
              );
            }
          }
          if (eliminated.length === 0 && players.length > 1) {
            const forced = randomChoice(players);
            eliminated.push(forced);
            await showCinematicPlayers(
              [{ name: forced, img: getCharImg(forced) }],
              `${forced} slipped at the last second and is eliminated!`,
              2000
            );
          }
          return eliminated;
        }
        case "Squid Game": {
          // Duel until one remains, all others eliminated
          const eliminated = [];
          let duelers = [...players];
          while (duelers.length > 1) {
            const a = duelers.pop();
            const b = duelers.pop();
            const winner = randomChoice([a, b]);
            const loser = winner === a ? b : a;
            await showCinematicPlayers(
              [
                { name: winner, img: getCharImg(winner) },
                { name: loser, img: getCharImg(loser) }
              ],
              `${winner} pushes ${loser}. ${loser} eliminated!`,
              2500
            );
            eliminated.push(loser);
            duelers.push(winner);
          }
          return eliminated;
        }
  case "Night Attack": {
    let eliminated = [];
    const shuffled = [...players].sort(() => Math.random() - 0.5);
    for (let i = 0; i < shuffled.length; i++) {
      // Reduce chance from 0.2 to 0.05 (5%)
      if (Math.random() < 0.05 && shuffled.length > 1) {
        // Pick a random attacker
        let attacker;
        do { attacker = randomChoice(shuffled); } while (attacker === shuffled[i] && shuffled.length > 1);
        eliminated.push(shuffled[i]);
        await showCinematicPlayers(
          [
            { name: attacker, img: getCharImg(attacker) },
            { name: shuffled[i], img: getCharImg(shuffled[i]) }
          ],
          `${attacker} attacked ${shuffled[i]}. ${shuffled[i]} eliminated!`,
          2200
        );
      }
    }
    if (eliminated.length === 0 && players.length > 1) {
      const attacker = randomChoice(players);
      let victim;
      do { victim = randomChoice(players); } while (victim === attacker && players.length > 1);
      eliminated.push(victim);
      await showCinematicPlayers(
        [
          { name: attacker, img: getCharImg(attacker) },
          { name: victim, img: getCharImg(victim) }
        ],
        `${attacker} attacked ${victim}. ${victim} eliminated!`,
        2200
      );
    }
    return eliminated;
  }
        default:
          return [];
      }
    },
    async increasePrize() {
      const prev = currentPrize;
      currentPrize += 100000;
      await tweenNumber(prev, currentPrize, 800);
    },
    async vipComment() {
      if (Math.random() < 0.4) {
        const comment = randomChoice([
          "That one was pathetic.",
          "Brutal! Just how I like it.",
          "Place your bets!",
          "He didnâ€™t stand a chance...",
          "Delightful chaos.",
          "These peasants amuse me."
        ]);
        await showCinematicText(`ðŸŽ© VIP: ${comment}`, 1700);
      }
    }
  };

  startGameBtn.addEventListener("click", async () => {
    // Fade out start screen
    startScreen.classList.add('hide');
    await new Promise(res => setTimeout(res, 700));
    startScreen.style.display = 'none';
    // Fade in game screen
    gameScreen.style.display = 'flex';
    await new Promise(res => setTimeout(res, 50));
    gameScreen.classList.remove('hide');
    GameManager.startGame();
  });

  renderCharacterGrid();
  checkStartButton();
})();
</script>
</body>
</html>
